##  六、Shell算术运算符

### 6.1. expr

expr(evaluate expressions)，表达式求值

#### 6.1.1 整数求值表达式

直接使用`expr 1 + 1`就能得到结果2，需要注意的是：

- 运算符、每个数字之间都是要有空格的，不然就是一个字符串;
- 使用乘号的时候要使用转义符号`\*`;
- 四则运算中，使用了小括号(),也需要转义`\( 1 + 1 \)`;
- 只对整数进行运算。

还可以直接把结果赋值给变量(在交互式shell)：

```shell
res=`expr 1 + 1`
echo $res
echo `expr 2 \* 3`   # 这里一定要转义符
expr 2 \* 3   # 不要echo，这样写也是可以直接出结果
echo `expr \( 10 + 10 \) \* 2`    # 符号与数字之间也一定要转义符
```

Tips：整个表达式是要用反引号括起来的。

#### 6.1.2 字符串相关

注意这下面字符串的第一个字符的下标都是从`1`开始的。

##### (1) 计算字符串长度

语法：`expr length 字符串` 

> expr length "hello"    # 返回得到：5

##### (2) 截取字符串

语法：`expr substr 字符串 start n `

- start：截取字符串的起始位置，注意是从`1`开始;
- n：截取字符串的长度。

>expr substr "hello" 2 1      # 返回得到的是：e

Tips：

- 这里只能是字符串，不能是引用的变量；相反，上面[这里](#3.4. 字符串截取)截取字符串是引用变量的方式。
- expr下标都是从1开始的，而上面字符串的操作，下标都是从0开始的。

##### (3) 获取第一个字符出现的位置

语法：`expr index 字符串 需查找的字符 `

> expr index "hello" e      # 返回得到的是：2

##### (4) 正则匹配

它可以理解为，返回的是匹配的字符串的长度。

方式一：`expr match 字符串 正则表达式` 

> expr match "hello world" ".*l"    # 返回得到的是：10

方式二：`expr 字符串 : 正则表达式` 

> expr "hello world" : ".*e"    # 返回得到的是：2 

### 6.2. (()) 多表达式计算推荐

​	双小括号`(())`，用于进行数学运算能表达式的执行，可使用$获取表达式的结构，这和使用$获取变量是一样的。用法：

- 括号内赋值：((变量名=整数表达式))
- 括号外赋值：变量名=$((整数变道时))  # 这里的等号两边一定不能有空格
- 多表达式赋值：((变量名1=整数表达式1, 变量名2=整数表达式2 ...))
- 与if条件语句代培使用：if ((整数表达式))  # 里面可结合逻辑判断

vim一个123.sh脚本：

```shell
#!/bin/bash
# 在`(())`里可以直接赋值，不用$去取变量；且这里面有没有空格无所谓，它会自己去解析
((a=1+6))
((b = a + 1))
((c= b +1))
echo "a=${a}, b=${b}, c=${c}"
# 还可以这样输出：
echo $((a+b))

# (())可以多个表达式同时赋值（注意之间是用`,`隔开）
((a=1+1, b=a+1, c=b+2))

# 赋值写法（这可以写到一行，也可以不）
a=$((1 + 2)) b=$((a + 1)) c=$((b +1))  # 注意只有在(())里面才可以可有可无空格，但是其它该有空格、不该有空格的地方还是要严格执行，比如这里 b = $((a + 1)) 就一定是错的，这等号两边不能有空格
echo "a=${a}, b=${b}, c=${c}"

# 可用于逻辑表达式，在if中使用
if ((a>7 && b==c))   # 注意在这(())才对空格没要求，其它地方一定要严格遵守(上面就也是这里的判断，中括号与变量之间要有空格)
then
	echo "判断成立"
else
	echo "这是判断不成立"
fi
```

### 6.3. let (赋值推荐)

​	let命令和双小括号在数字计算方面功能一样，但是没有(())功能强大，let只能用于赋值计算，不可以用于if的条件判断。

一般用于赋值算是最简单的变量赋值的方法，语法：

- `let 变量名=整数计算表达式`;  # let后面的式子一个空格都不能有
- `let 变量名1=整数运算表达式1 变量名2=整数运算表达式2 ...`   # 空格隔开

在交互式shell下：

```shell
a=1 b=2
echo let a+b   # 这只会直接把后面这当字符串输出
let c=a+b      # 必须搞一个变量来接收
echo $c        # 3
echo $((a+b))  # 3 这里是可以这样输出的
```

vim一个123.sh

```shell
#!/bin/baslet 
let a=1+1
let b=a+1    # 这表达式之间一个空格都不能有
let c=b+1    
echo "a=${a},b=${b},c=${c}"

let a=1+6 b=a+1 c=b+1   # 这里的多表达式之间是用`空格`隔开的
echo "a=${a},b=${b},c=${c}"
```

### 6.4 $[] (直接求值输出)

它也是进行整数运算，但是只能对单个表达式的计算求值与输出。

语法：$[表达式]  # 会直接对表达式计算并获取结果，且内部是不可以赋值给变量的，那也就是说这里面是没有等号=的。

在交互式shell中：

``` shell
a=1
echo $[a+1] $[2+3]    # 结果是：2 5
echo "$[a+1] $[2+3]"  # 结果也是：2 5
echo $[(10+15)*2]    # 50 一定要echo
echo $(((10+15)*2))  # 4、5行都是不需要转义的
echo `expr \( 10 + 15 \) \* 2`  # 这个就是严格需要空格的，还需要转义字符和反引号
expr \( 10 + 15 \) \* 2   # 不一定要echo
```

### 6.5. bc

​	Bash shell内置了对整数运算的支持，但是并不支持浮点运算，而linux bc(basic calculator)命令可以方便的进行浮点运算，bc命令是linux简单的计算器，能进行进制间的转换，以及常见的运算。如果找不到bc命令，直接yum install bc就好了。

语法：bc [options] [参数]，一般就是直接`bc`或`bc -l` 

- -l：使用标准的数学库，例如使用内置函数时就需要要这个参数;
- -q：直接bc会有一些欢迎信息，可以-q来去掉。
- 进去后是交互界面，可以输入quit退出

==实例一==：bc执行计算任务的文件

创建一个task.txt文件，编辑文件内容(一个计算表达式一行)

> 1+2+3+4+5
> 12*23+45

然后执行命令`bc -q task.txt`就能得到整个文件的计算结果。

***

==内置变量==：

| 变量名     | 作用                                      |
| ---------- | ----------------------------------------- |
| scale      | 对计算结果指定精度，默认为0，即不使用小数 |
| ibase      | 指定输入数字的进制，默认为十进制          |
| obase      | 指定输出数字的进制，默认为十进制          |
| last 或者. | 获取最近一次计算打印结果的数字            |

==内置函数==(这必须要-l参数才有使用)：

| 函数名 | 作用                         |
| ------ | ---------------------------- |
| s(x)   | 计算x的正弦值，x是弧度值     |
| c(x)   | 计算x的余弦值，x是弧度值     |
| a(x)   | 计算x的反正切值，返回弧度值  |
| l(x)   | 计算x的自然对数              |
| e(x)   | 求e的x次方                   |
| j(n,x) | 贝塞尔函数，计算从n到x的阶数 |

#### 6.5.1 交互操作

下面是进到bc操作界面（bc互动式的数学运算）：

```shell
# 一般直接计算就行
10/3      # 结果会是3，因为默认精度是0，不启用小数

sclae=2   # 后面的精度都会是2了
10/3      # 3.33
10/2      # 5.00

obase=2   # 这就是把输出改成2进制
7      # 回车就会得到 111
obase=8;100      # 回车就会得到144——8进制的100

e(2)    # 使用内置函数，进入bc时一定要加-l
```

#### 6.5.2 借助管道

直接进行bc的表达式计算输出：echo "expression" | bc [options]

- "expression"表达式必须符合bc命令要求的公式;
- "expression"表达式里面可以引用shell变量。

在shell交互界面：

```shell
echo "10/3" | bc      # 3
echo "scale=5; 10/3" | bc   # 3.33333
echo "e(3)" | bc -l       # 使用内置函数，必须加-l
echo "1+1; 2+2" | bc   # 多个式子一起

a=5   # 定义一个shell变量
echo "b=$a+1; b" | bc     # $a引用shell变量，b是bc中的变量，直接打印就好了，前面不用加$
```

***

还可以将bc结果赋值给Shell变量：

方式一：

```shell
var1=`echo "scale=2; e(2)/3" | bc -l`  # 注意这里是一对反引号，
echo $var1         # 2.46
```

方式二：

>var2=$(echo "scale=2; e(2)/3" | bc -l)
>
>echo $var2         # 2.46

$()与``功能一样，都是执行里面的命令，区别：

- ``是所有linux系统支持的，兼容性较好;
- $()不是所有linux系统支持，兼容性没那么好，但是不容易看混淆。

#### 6.5.3 重定向到shell变量

​	上一点那个表达式一般就写一行，当有很多行的时候，就不好用了，就可以输入多行表达式，更加清晰，语法：

方式一：

```
var1=`bc [options] << EOF
表达式1
表达式2
...
EOF       # EOF是比较统一的洗发==写法，是可以换成一对别的字母
`         # 别忘了这对反引号
```

方式二：

```
var1=$(bc [options] << EOF
表达式1
表达式2
...
EOF       
)         # 这就是把一对反引号``变成了$()
```

实例(在交互式shell界面)：

```shell
var1=`bc << EOF
> 1+1
> 2+2
> 3+3
> EOF 
> `          # 一开始不要给这个，不然回车就是执行了，一定要最后给
echo $var1    # 2 4 6  这结果就是一个字符串

var2=$(bc -l << EOF
> scale=2; 10/3
> e(2);
> 1+1
> EOF
> )           # 这个括号也定要最后给
echo $var2    # 3.33 7.38 2    也是字符串
```

Tips:

- 6.5.2、6.5.3都是可以把结果赋值给shell变量的，然后就可以对shell变零进行一些操作;
- 上面的task.txt文件操作虽然也可以完成多上输入，但是是没办法把结果赋值给shell变量的;
- 多行计算，结果赋值的shell变量就是一个字符串，每行之间的结果是用空格字符隔开的，整体就是一个字符串，注意。